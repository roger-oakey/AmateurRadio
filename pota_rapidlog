#!/usr/bin/python3

###############################################################################
###############################################################################
####
#### Simple POTA logging program that allows freeform input of contacts
####
###############################################################################
###############################################################################

####
#### Global definitions
####

rapid_logger_version = str(1)

default_split = r'[,:;\s\t]+'
rapidlog_help_file = "pota_rapidlog.help"
adif_extension = ".adif"

####
#### Import support modules
####

import os
import re
import shutil
import sys
import time

#print(sys.argv)

####
#### Import large tables and help files to de-clutter the program
####

import adif
import pota_rapidlog

#
#This is the order that the ADIF tags will be placed into the file for
#consistency
#
adif_tag_support_and_order = [
    "QSO_DATE",
    "TIME_ON",
    "STATION_CALLSIGN",
    "OPERATOR",
    "CALL",
    "BAND",
    "MODE",
    "SUBMODE",
    "MY_SIG",
    "MY_SIG_INFO",
    "MY_STATE",
    "SIG",
    "SIG_INFO",
    "RST_SENT",
    "RST_RCVD",
    "FREQ",
    "FREQ_RX",
    "TX_PWR",
    "RX_PWR"
    ]

####
#### Subroutines
####

def get_input(help_text, prompt):
    """
    Get input string from console.
    Print rapid logger help if "HELP" is specified and then ask for input again.
    Strip off all leading and trailing blanks on input string.
    Upcase input string if requested (Default).

    Arguments:
        help_text:  Text to print if help on this prompt is requested
        prompt:     String to print as question prompt

    Returns:
        String read from console. If no input, a null string is returned ("")
            which is boolean False in Python.
    """

    while(True):
        #
        #Get input, strip blanks and upcase
        #
        text = str(input(prompt)).strip().upper()
        #
        #If "EXIT" entered, exit
        #
        if text == "EXIT":
            exit()

        #
        #If input is "?" or <Enter> without a default (question having a "[" in
        #it), print help text
        #
        if (text == "?") or not (text or re.search(r'\[', prompt)):
            print("""
Type "EXIT" to exit logger.
Type "?" for this help.
""" + help_text + """
Type "HELP" for more information.
""")
            continue

        #
        #If help file is not requested, get out of the query loop.
        #
        if text != "HELP":
            break

        #
        #If the help file is missing, report and error but continue
        #
        if not os.path.exists(rapidlog_help_file):
            print ("POTA rapid logger help file missing")
            continue

        #
        #Print the help file, then re-ask for input
        #
        f = open(rapidlog_help_file, "r")
        print (f.read())
        f.close()

    #
    #Return the text from the console
    #
    return(text)

def get_yes_no(help_text, prompt, default="Y"):
    """
    Get input string from console.
    Print rapid logger help if "HELP" is specified and then ask for input again.
    Strip off all leading and trailing blanks on input string.
    Upcase input string if requested (Default).

    Arguments:
        help_text:  Text to print if help on this prompt is requested
        prompt:     String to print as question prompt
        default:    Default, Y or N if nothing typed

    Returns:
        True if yes
        False if no
    """

    default_prompt = {"Y" : " [(Y), n]",
        "N" : " [(N), y]"}

    default = default[:1].upper()

    #
    #Runtime programming check: Make sure "Y" or "N" was supplied as a default.
    #If this fails, the program immediately exits.
    #
    if default not in default_prompt:
        print("""
Severe error: Default supplied for get_yes_no was "{}". It must be "Y" or "N"
""".format(default))
        exit (1)

    #
    #Keep trying until you get a "Y", "N" or an <Enter> (which says take the
    #default).
    #
    while(True):
    
        #
        #Ask the question and get a response.
        #
        answer = get_input(help_text,
            prompt.rstrip() + default_prompt[default] + ": ")

        #
        #If just <Enter>, set the response to the default.
        #
        if not answer:
            answer = default

        #
        #If valid response, return True if "Y", False if "N".
        #
        if answer in default_prompt:
            return(answer == "Y")

        #
        #Invalid response, report error and ask again.
        #
        print("""
Error: First character of answer must be 'Y' or 'N' or <Enter> to use the
       default of "{}".
""".format(default))

def valid_callsign(callsign, slash=True):
    """
    Validate the callsign against the expected format

    Arguments:
        callsign:   String containing callsign

    Returns:
        True if callsign formatted correctly
        False if callsign formatted incorrectly
    """

    if slash:
        if not re.fullmatch(r'[A-Z0-9]{3,}(/[A-Z0-9]+|$)', callsign):
            #
            #If an error is found, report it
            #
            print ("""
Error: "{}" is not a valid format for a callsign.
       It must be three or more letters and digits only.
       Callsign may be terminated by a "/" followed by one or more letters and
       digits.
       Please re-enter callsign.
""".format(callsign))
            #
            #Return invalid
            #
            return(False)
    else:
        if not re.fullmatch(r'[A-Z0-9]{3,}', callsign):
            #
            #If an error is found, report it
            #
            print ("""
Error: "{}" is not a valid format for a callsign.
       It must be three or more letters and digits only. It may NOT contain a
       "/"!
       Please re-enter callsign.
""".format(callsign))
            #
            #Return invalid
            #
            return(False)
    #
    #Return valid
    #
    return(True)

def get_filename(callsign, park, state):
    """
    Generate full filename based on the callsign, park date and time and
    optional identification. Replace "/" in callsigns with "-"

    Arguments:
        callsign:   String containing operator callsign. May include "/".
        park:       String containing operator park ID
        state:      Optional state identification

    Returns:
        CallSign_Park[_state].adif
    """

    if state:
        state = "_" + state
    return(callsign.replace("/", "-") + "_" + park + state + adif_extension)

def see_if_band(band):
    """
    See if valid band specified. If so, return it. If not, return False

    Arguments:
        band:   String containing band to be verified

    Returns:
        Band string if correct
        False if band string incorrectly formatted or not a valid band
    """

    #
    #If it's a band, return it.
    #
    if band in adif.band_mapping:
        return([band, ["", ""]])
    else:
        return(False)

def see_if_frequency(freq):
    """
    See if valid frequency specified. If so, return it. If not, return False

    Arguments:
        freq:   String containing frequency/frequencies to be verified

    Returns:
        Band and array of frequencies if correctly formatted
        False if frequencies are incorrectly formatted or not a valid
            frequency
    """

    freq = re.split(default_split, freq)

    #
    #If more than two frequencies specified, it's an error
    #
    if len(freq) > 2:
        return(False)

    #
    #If only one frequency specified, copy to second frequency
    #
    if len(freq) < 2:
        freq.append(freq[0])

    #
    #Check transmit frequency for a valid format
    #
    if not re.fullmatch(r'(\.\d+)|(\d+\.?\d*)', freq[0]):
        #
        #Not a correctly formatted frequency, return False
        return(False)

    #
    #Determine band
    #
    band = adif.freq_to_band(freq[0])
    if not band:
        #
        #Frequency not in valid frequency range
        #
        return(False)

    #
    #Check receive frequency for a valid format
    #
    if not re.fullmatch(r'(\.\d+)|(\d+\.?\d*)', freq[1]):
        #
        #Not a correctly formatted frequency, return False
        return(False)

    #
    #see if valid frequency
    #
    if not adif.freq_to_band(freq[1]):
        #
        #Frequency not in valid frequency range
        #
        return(False)

    #
    #Retrun band and xmit and rcv frequencies
    #
    return ([band, freq])

def see_if_power(power):
    """
    See if valid power specified. If so, return it. If not, return False

    Arguments:
        band:   String containing power to be verified

    Returns:
        Power string if correct
        False if band string incorrectly formatted
    """

    #
    #If it's a power, return it.
    #
    if re.fullmatch(r'\d+W', power):
        return(power[:-1])

    return(False)

def see_if_mode(mode_submode):
    """
    See if mode (and submode) specified. If so, return the mode and submode.

    Arguments:
        mode_submode:   String containing mode (and submode) to be verified

    Returns:
        [mode, submode] is valid.
        False if mode or submode not valid
    """

    #
    #Some submodes can have blanks in them (thanks a lot, folks). So I strip
    #the blanks out for comparing, but keep around the original format for
    #reporting
    #
    #OLIVIA
    #OLIVIA OLIVIA8/500
    #OLIVIA8/500
    #
    #So I need to generate all the possible permutations and combinations of
    #mode and submode and throw it at the code that identifies it to see if I
    #get a match somehow.
    #

    #
    #Breakup the mode and submode
    #
    mode_submode = re.split(default_split, mode_submode)
    
    #
    #Pull off mode and re-create submode in case they're blanks in it (like the
    #OLIVIA submodes have)
    #
    mode_text = mode_submode.pop(0)
    submode_text = "".join(mode_submode)

    #
    #Try identifying it as both a mode and submode and just a submode
    #
    for (mode, submode) in [[mode_text, submode_text], [mode_text + submode_text, ""]]:
        if submode:
            #
            #We have a mode AND submode specified. See if it's a valid combo
            #
            if mode in adif.re_modes_and_submodes:
                #
                #Mode looks good, see if this is a valid submode for that mode
                #
                if submode in adif.re_modes_and_submodes[mode]:
                    return([mode, adif.re_modes_and_submodes[mode][submode]])
        else:
            #
            #We only have a mode. It could also be only a submode. Do an
            #exaustive search of modes and submodes for the string
            #
            if mode in adif.re_modes_and_submodes:
                #
                #Only a valid mode is specified. Return it and no submode
                #
                return([mode, ""])
            #
            #Did not find a mode match, do an exhaustive search through all the
            #submodes for a match
            #
            for mode_index in adif.re_modes_and_submodes.keys():
                if mode in adif.re_modes_and_submodes[mode_index]:
                    return([mode_index, adif.re_modes_and_submodes[mode_index][mode]])

    #
    #Not a valid mode and submode
    #
    return(False)

###############################################################################
###############################################################################
####
#### Start of main program
####
###############################################################################
###############################################################################

####
#### Ask what operator(s) are sharing this microphone
####

#
#Multiple operators may be specified if you're working with more than one
#operator at a radio. When a contact is made, it is possible to exclude
#an operator in case they're not available for that particular contact.
#

help_text = """
Enter one or more operator callsigns (operators "sharing a microphone").
    Callsigns may include the "/" character.
    Examples: "K0RLO", "K0RLO W1JU" or "K0RLO/R01"
"""
while(True):
    operators = get_input(help_text, "Operator callsign(s): ")

    #
    #Validate callsign format of all operators supplied
    #
    bad_callsign = False
    ops = {}
    for operator in re.split(default_split, operators):
        #
        #Save operator in dictonary to eliminate duplicates
        #
        ops[operator] = True
        #
        #Validate callsign
        #
        bad_callsign = bad_callsign or (not valid_callsign(operator))

    #
    #If a bad callsign format was detected, ask the callsign question again
    #
    if not bad_callsign:
        break

#
#Save unique operators
#
operators = sorted(ops.keys())

####
#### Ask what park(s) are being activated
####

#
#Multiple parks may be specified so if you're in a park next to a national
#scenic trail, for example, you can log both at once.
#
help_text = """
Enter one or more park codes. Multiple park codes are when yo're activating
    multiple parks from one location.
    Examples: "K-1111" or "K-1111 K-2222"
"""
while(True):
    parks = get_input(help_text, "Park code(s): ")

    #
    #Validate park format
    #
    bad_park = False
    pks = {}
    for park in re.split(default_split, parks):
        #
        #Save park in dictonary to eliminate duplicates
        #
        pks[park] = True
        #
        #See if park format correct
        #
        if not re.fullmatch(r'[A-Z]+-\d{4}', park):
            #
            #If a park identifier has a bad format, report it
            #
            print ("""
Error: "{}" is not a valid format for a park.
       It must be one or more lettes, follwed by a dash and then four digits.
       Please re-enter park number.
""".format(park))
            bad_park = True

    #
    #If a bad park format was detected, ask the park question again
    #
    if not bad_park:
        break

#
#Save unique parks
#
parks = sorted(pks.keys())

####
#### Ask for state
####

help_text = """
Type <Enter> if no state specified.
Enter state or province identifier
    Examples: "CO" or "US-CO"
"""
while(True):
    #
    #Get optional state information that will be added at end of filename
    #
    state = get_input(help_text, 'State/province/etc. of activation [NONE]: ')

    #
    #If no state, get out of loop
    #
    if not state:
        break

    #
    #Validate state information
    #
    if re.fullmatch(r'[A-Z]+(-[A-Z]+|$)', state):
        #
        #We have the state
        #
        break

    #
    #Report error and ask again
    #
    print("""
Error: {} is not a valid state format. State/province/etc. must start and end
       with alphanumeric characters and can optionally contain one "-".
""".format(state))


####
#### Ask if this activation has a special event callsign
####

#
#Note: only one callsign allowed for a special event.
#
while(True):
    hekp_text = """
Type <Enter> if this is not a special event.
Enter the special event callsign.
    Examples: "W4W" or "W3MX"
"""
    special_event_callsign = get_input(help_text,
        'Special event callsign [NONE]: ')

    #
    #If nothing entered, leave special_event_callsign blank
    #
    if not special_event_callsign:
        break

    #
    #Validate callsign of special event
    #
    if valid_callsign(special_event_callsign, slash=False):
        #
        #If valid, exit
        #
        break

    #
    #No need to report an error because valid_callsign did
    #

####
#### See if this is a continuation of an existing log or if a new log should
#### be started.
####

#
#Determine filename(s) based on special event or not
#
if special_event_callsign:
    callsigns = [special_event_callsign]
else:
    callsigns = operators

help_text = """
Enter "N" (or just press <Enter>) if you wish to continue to log hunter
    contacts in the existing file.
Enter "Y" if you wish to archive the existing log file (with the last modified
    date included in the extension) and start a new log file.
"""

for operator in callsigns:
    for park in parks:
        filename = get_filename(operator, park, state)
        #
        #If a log file by this name does not currently exist, keep looking
        #
        if not os.path.exists(filename):
            continue

        #
        #Get last modified time for this file and prompt if it should be archived
        #
        mtime = time.localtime(os.path.getmtime(filename))
        prompt = """
POTA log already exists for this callsign and park: {}
Last modified on {} (Local time)
Do you wish to archive it and start a new log""".format(filename,
            time.strftime("%Y/%m/%d %H:%M:%S", mtime))

        #
        #New log file to start, rename the old file
        #
        if get_yes_no(help_text, prompt, "N"):
            new_filename = filename + time.strftime("_%Y%m%d-%H%M%S", mtime)
            print("""
Renaming existing log file "{}" to "{}"
""".format(filename, new_filename))
            os.rename(filename, new_filename)


####
#### Get the operating frequency or band
####

while(True):
    help_text = """
Enter the band.
    Examples: "20M" or "70CM"
Enter the transmit frequency. If split frequency enter transmit frequency
    first, followed by the recieve frequency.
    Examples: "14.215" or "114.215 14.275"
"""
    freq = get_input(help_text, "Band or frequency: ")

    #
    #Validate band or frequency
    #
    test = see_if_band(freq)
    if test:
        (band, frequency) = test
        break

    test = see_if_frequency(freq)
    if test:
        (band, frequency) = test
        break

    #
    #Report error and ask again
    #
    print("""
Error: Incorrectly formatted band or frequency. Band should be entered as "20M"
       or "70CM" or frequency should be entered as "14.215". If split
       frequencies, enter transmit frequency first ("114.215 14.275").
""")

####
#### Get the operating mode
####

while(True):
    help_text = """
Enter the QSO mode and, if desired, the submode. Note that you can specify JUST
    the submode and the mode will be determined.
    Examples: "CW", "SSB", "SSB USB", "LSB", "OLIVIA 4/125"
"""
    mode = get_input(help_text, "Operating mode: ")

    #
    #Validate mode
    #
    test = see_if_mode(mode)
    if test:
        (mode, submode) = test
        break

    #
    #Report error and ask again
    #
    report_text = re.split(default_split, mode)
    mode = report_text.pop(0)
    submode = " ".join(report_text)
    if submode:
        print("""
Error: {0} is not a recognized mode or {1} is not a recognized
       submode of {0}. Please input mode and submode such as
       "SSB USB" or"JT9 JT9H FAST".
""".format(mode))
    else:
        print("""
Error: {} is not a recognized mode or submode. Input mode such as
       "CW", "SSB" or "LSB".
""".format(mode))

#
#Do not report power unless specified
#
xmit_power = ""

#### Now log the hunters
####
#### At minimum you just need the callsign. The callsign must be
#### specified first.
####
#### Optionally you can supply one or more parks identifiers, RST (hunter's RST
#### followed by operator's RST) and the hunter's power output.
####
#### These fields can be intermingled - they'll be sorted out.
####
#### In addition, you can switch bands, frequencies, modes or transmit power
#### by just typing a band, mode, frequency or power alone on a line.
####

while (True):
    #
    #See if power is being reported
    #
    if xmit_power:
        report_power = xmit_power + "W"
    else:
        report_power = "NOPWR"

    if submode:
        report_mode = submode
    else:
        report_mode = mode

    #
    #Get hunter information
    #
    help_text = """
At this prompt you can do the following:
    Specify a new mode and optionally a submode, such as "CW" or "SSB USB".
    Specify a new band, such as "20M" (frequency will not be recorded).
    Specify a new frequency or transmit AND receive frequency, such as
        "14.215" or "14.215 14.275" (this will automatically set the band).
    Specify a new transmit power, such as "100W". Enter "0W" to stop recording
        a transmit power.

    Enter a hunter contact:
        Enter the hunter's callsign, followed by optional information like sent
        and received RSTs, hunter power and park to park identifier(s).

        All optional information may be entered in any order.
"""
    hunter_info = get_input(help_text, 
"({}:{}:{}) Hunter contact information: ".format(band,report_mode,report_power))

    #
    #See if a new band has been specified
    #
    test = see_if_band(hunter_info)
    if test:
        #
        #Save both band and no frequencies
        #
        (band, frequency) = test
        continue

    #
    #See if a new frequency has been specified
    #
    test = see_if_frequency(hunter_info)
    if test:
        #
        #Save both band and frequency
        #
        (band, frequency) = test
        continue

    #
    #See if a new mode has been specified
    #
    test = see_if_mode(hunter_info)
    if test:
        (mode, submode) = test
        continue

    #
    #See if a new power has been specified
    #
    test = see_if_power(hunter_info)
    if test:
        if test == "0":
            #
            #Do not report power any longer
            #
            xmit_power = ""
        else:
            xmit_power = test
        continue

    ####
    #### Looks like we have a contact to log, log it
    ####

    #
    #Get the current GMT now so all logs for this hunter show
    #the same time.
    #
    utc = time.gmtime()

    #
    #Split input line to see if this is just a hunter (only character
    #string) or RST reports and/or a park-to-park which will specify
    #the park as following character strings.
    #
    hunter_info = re.split(default_split, hunter_info)

    #
    #Get the hunter callsign which is the first (and perhaps
    #only) contents of the list. Parks and RSTs (if any) remain.
    #
    hunter_callsign = hunter_info.pop(0)

    #
    #Start off with checking if it's a bad callsign
    #
    bad_entry = not valid_callsign(hunter_callsign)

    #
    #Split the remainder of the info into RST reports and parks, if any
    #
    hunter_parks = {}
    hunter_power = []
    rst = []
    bad_strings = []

    #
    #Look through the free-float format and save optional park, RST and power,
    #if any. Report anything that doesn't match as an error.
    #
    for component in hunter_info:
        #
        #If it's a park, save it as a park
        #
        if re.fullmatch(r'[A-Z]+-\d{4}', component):
            #
            #Eliminate duplicate parks by using dictonary
            #
            hunter_parks[component] = True
            continue
        #
        #If it's an RST, save it as an RST
        #
        if re.fullmatch(r'[1-5][1-9]{1,2}', component):
            #
            #It's an RST number, save it as an RST
            #
            rst.append(component)
            continue
        #
        #If it's a power, save it as a power
        #
        if re.fullmatch(r'\d{1,4}W', component):
            #
            #It's an hunter power, save it as an power removing the "W"
            #
            hunter_power.append(component[:-1])
            continue

        #
        #Unrecognized string, save error
        #
        bad_strings.append(component)
        bad_entry = True

    #
    #Verify we have no more than one power entry. Default to no rcv power.
    #
    recv_power = ""
    if hunter_power:
        if len(hunter_power) > 1:
            print("""
Error: More than one power entry. The hunter can only have one power entered.
""")
            bad_entry = True
        #
        #Save recieve power
        #
        recv_power = hunter_power[0]


    #
    #Verify we have no more than 2 RST entries
    #
    rst_sent = ""
    rst_rcvd = ""
    if rst:
        if len(rst) > 2:
            print("""
Error: More than two RST entries. The RST report you send to the hunter is the
first RST report, the second RST is what the hunter reports to you.
""")
            #
            #Ask for all the info again
            #
            bad_entry = True
        rst_sent = rst[0]
        if len(rst) > 1:
            rst_rcvd = rst[1]

    #
    #Report any strings we didn't recognize
    #
    for errors in bad_strings:
        #
        #Report error
        #
        print("""
Error: "{}" is not a recognized entry. Press <Enter> to get help on how to
       enter information in the 
""".format(errors))
        bad_entry = True
    #
    #If we got any bad information, skip processing and ask for
    #hunter callsign, RST and park(s) again.
    #
    if bad_entry:
        continue

    ####
    #### Start assembling the record to be logged, start with the stuff
    #### common to all the record(s) to be written.
    ####
    log_record = {}
    log_record["CALL"] = hunter_callsign
    log_record["QSO_DATE"] = time.strftime("%Y%m%d", utc)
    log_record["TIME_ON"] = time.strftime("%H%M%S", utc)
    log_record["BAND"] = band
    log_record["MODE"] = mode
    if submode:
        log_record["SUBMODE"] = submode
    if state:
        log_record["MY_STATE"] = state
    log_record["MY_SIG"] = "POTA"
    if frequency[0]:
        log_record["FREQ"] = frequency[0]
        if frequency[0] != frequency[1]:
            log_record["FREQ_RX"] = frequency[1]
    if xmit_power:
        log_record["TX_PWR"] = xmit_power
    if recv_power:
        log_record["RX_PWR"] = recv_power

    #
    #Log contacts for all operators (any input will skip an
    #operator from having a log entry)
    #
    help_text = """
Enter "Y" (or just press <Enter>) if the specified operator has performed an
    exchange with the hunter and they wish to receive credit for the contact.
Enter "N" if the specified operator is unable to perform an exchange with
    the hunter or they should not receive credit for the contact.
"""
    for operator in operators:
        if ((len(operators) > 1) and
            not get_yes_no(help_text, "Log contact for " + operator, "Y")):
            #
            #If "N" typed, skip this operator
            #
            continue

        #
        #Now write a file for each park we're at
        #
        for park in parks:
            #
            #Determine filename based on special_event_callsign or not
            #
            if special_event_callsign:
                log_record["STATION_CALLSIGN"] = special_event_callsign
                log_record["OPERATOR"] = operator
            else:
                log_record["STATION_CALLSIGN"] = operator

            #
            #Filename is always based on the STATION_CALLSIGN
            #
            log_filename = get_filename(log_record["STATION_CALLSIGN"], park, state)

            #
            #We've waited until we REALLY need to create a log file, time to
            #see if we need to create the file and write the header
            #
            if not os.path.exists(log_filename):
                #
                #If this log file does not yet exist, create a header
                #
                f = open(log_filename, "w")
                f.write(("Parks On The Air (POTA) rapid logger\n" +
                    adif.tag("PROGRAMID", "POTA rapid logger") + "\n" +
                    adif.tag("PROGRAMVERSION", rapid_logger_version) +
                    "\n" +
                    adif.tag("CREATED_TIMESTAMP",
                        time.strftime("%Y%m%d %H%M%S", utc)) +
                        "<EOH>\n"))
                f.close()

            #
            #Add this park to the record to be written
            #
            log_record["MY_SIG_INFO"] = park

            if hunter_parks:
                #
                #We have one or more park-to-park contacts to log, open
                #the file and write [perhaps] multiple records
                #
                f = open(log_filename, "a")
                #
                #We're writing Park to park information, so setup the SIG
                log_record["SIG"] = "POTA"

                #
                #Now write records for all park to park parks
                #
                for hunter_park in sorted(hunter_parks.keys()):
                    #
                    #This is a park to park, fill in the addiitional
                    #information
                    #
                    log_record["SIG_INFO"] = hunter_park
                    f.write(adif.record(log_record, adif_tag_support_and_order))
                #
                #Keep the file closed to avoid dataloss
                #
                f.close()
            else:
                #
                #No park to park, write the record for this normal hunter
                #contact
                #
                f = open(log_filename, "a")
                f.write(adif.record(log_record, adif_tag_support_and_order))
                #
                #Keep the file closed to avoid dataloss
                #
                f.close()

exit()
