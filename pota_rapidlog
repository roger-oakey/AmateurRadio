#!/usr/bin/python3

###############################################################################
###############################################################################
####
#### Simple POTA logging program that allows freeform input of contacts
####
###############################################################################
###############################################################################

####
#### Global definitions
####

pota_rapidlog_version = "1"

help = [
    None,
    """
*******************************************************************************

Note: Installation instructions at end of this help text.

pota_rapidlog

About pota_rapidlog:

    pota_rapidlog is a simple program that creates an ADIF file for POTA
    reporting. By avoiding a GUI (Graphical User Interface), pota_rapidlog
    allows fast, simple QWERTY data entry without having to click and select
    fields to create a log entry. This allows the user to stay "heads down" on
    the radio and not have to pay attention to the screen to select logging
    fields.

    pota_rapidlog supports changing of mode and band/frequency "on the fly"
    allowing you to jump around the spectrum (and modes) if needed or desired.

    pota_rapidlog supports freeform input. At the very minimum all you need to
    enter is a hunter's callsign and all the other ADIF fields required for
    POTA reporting will be filled out and stored. However, for you own logging
    other fields are typically desirable, so in addition to just the hunter's
    callsign you may enter the sent and received RST, the hunter's transmit
    power and add a comment. These fields are ignored by the POTA logging
    utility, but can be used to populate your personal logs with more complete
    data.

    pota_rapidlog will run on any system, Windows or Linux, that has Python3
    installed, but the primary platform which is was designed for are modern
    Chromebooks on which you can enable Linux. Chromebook installation will be
    detailed at the end of this help.

Running pota_rapidlog:

NOTE: At any question prompt you can type "?" and get detailed help for that
      specific question. If you type "HELP" this help will be printed again.

    After installing pota_rapidlog (see end of help) "cd" into the K0RLO
    directory, typically "cd ~/K0RLO" and type ./pota_rapidlog the following
    setup questions will be asked:

    Operator callsign(s):

        Enter your operator callsign. If you have muliple operators "sharing a
        microphone" on one radio, you can enter multiple callsigns on one line.
        Examples: "K0RLO", "K0RLO/mobile" or "K0RLO W1JU"

    Park code(s):

        Enter the park you're activating from. If you're activating multiple
        parks simultaneously (like being near a historic trail in a park) enter
        all the park identifiers on one line.
        Examples: "K-1211" or "K-1211 K-1214"

    State/province/etc. of activation [NONE]:

        This assists the POTA software identify what state you're located in
        if a park or trail crosses multiple states. Typically this isn't the
        case and you can just press <Enter> to leave this field blank.

    Special event callsign [NONE]:

        If you are doing a POTA club or group activation, enter the event's
        ONE callsign here. It can have a "/" designation if necessary.
        Examples: "W1BOB" or "W1BOB/R01"

NOTE: At this point pota_rapidlog knows the log file name. It will check to see
      if a log file of that name already exists. If it does, the following
      question will be asked:

        POTA log already exists for this callsign and park: K0RLO_K-1111.adif
        Last modified on 2022/09/02 15:26:01 (Local time)
        Do you wish to archive it and start a new log [(N), y]:

      Press <Enter> (default of "NO") if you wish to ADD to the existing log.
      Type "N"<Enter> if you wish the existing log to be renamed (it won't be
      lost) and a new log started. pota_rapidlog will display new filename of
      the renamed file.

    Band or frequency:

        The initial band or frequency being to be used. If you supply a
        frequency the band will automatically be calculated. If you're running
        split operations, enter the transmit followed by the receive frequency.
        If you enter a band, no frequency will be logged.
        Examples: "20M", "14.200" or if split, "14.200 14.300"

    Operating mode:

        The mode or submode that will be used for POTA contacts. You can
        specify a mode, a submode or both a mode and submode. If you specify
        both, the submode will be checked to assure that it's a submode of the
        mode specified. If only a submode is specified, the mode will be
        automatically determined.
        Examples: "CW", "SSB", "SSB USB" or "USB"

    (20M:USB:NOPWR) Hunter contact information:

        Contact entry:

            This is where you would start logging hunter contacts. Note that in
            this example we're using the "20M" band, our submode is "USB" and
            we have not specified a transmit power. At bare minimum all we need
            to do at this point to log a contact is to type in a hunter's
            callsign.
            Example: "w1ju"

            But you can do much more.

            If you and the hunter exchange RST information, you can enter that
            too in the order of your signal report to them, followed by
            optionally what they reported to you.
            Examples: "w1ju 59" or "w1ju 59 59"

            For park-to-park contacts, enter the park the hunter/ activator is
            calling from. If they're simultaneously activating parks, just
            enter ALL the parks they're activating from.
            Examples: "w1ju k-1111" or "w1ju k-1111 k-2222 k-3333"

            If your hunter is running 5 watts QRP, maybe you'd like to record
            their power.
            Examples: "w1ju 5w"

            If you wish to add a comment to the log, simply enclose it in
            double quotes.
            Examples: 'w1ju "My bud Harvey"'

            Most importantly, after the hunter's callsign (which MUST be
            entered first) ALL the above optional information may be entered in
            ANY ORDER! pota_rapidlog supports freeform entry and will correctly
            log all the information you give it.

            So the following hunter entries are ALL identical and would
            generate identical log entries:

                w1ju 59 58 k-1111 k-2222 5w "My bud Harvey"
                w1ju k-1111 k-2222 59 58 5w "My bud Harvey"
                w1ju 5w "My bud Harvey" k-1111 k-2222 59 58
                w1ju 5w "My bud Harvey" 59 k-1111 58 k-2222

NOTE: If you entered more than one operator to the "Operator callsign(s)"
      question, you will see the following question asked for each operator
      entered after entering a hunter contact:

        "Log contact for K0RLO [(Y), n]:"

      Just press <Enter> (default of "YES") to log a contact for this operator,
      or "N"<Enter> to not log the contact for the specified operator. This
      used when more than one operator is sharing a microphone and one of them
      steps away for a few minutes and does not participate in a couple of
      contacts - pota_rapidlog will not log the contacts for the absent
      operator.

        Changing frequency, mode and power:

            At the "Hunter contact information:" prompt you also can change
            your frequency (or band), mode and transmit power without
            restarting the program. Instead of entering a hunter's callsign as
            the first entry, do the following:

            To change the frequency, enter a new frequency or transmit and
            receive frequencies if split operations. By entering a frequency
            the band will automatically be calculated.
            Examples: "14.200" or "14.200 14.300"

            To change the band, enter a new band or transmit and receive band
            if split operations. By entering a band no frequency will be
            logged.
            Examples: "20m" or "20m 20m"

            To change the mode, enter a mode, a submode or both a mode and
            submode.  If you specify both, the submode will be checked to
            assure that it's a submode of the mode specified. If only a submode 
            is specified, the mode will be automatically determined.
            Examples: "CW", "SSB", "SSB USB" or "USB"

            To change your transmit power, enter a power in watts (whole
            numbers only) followed by a "W".
            Examples: "100w", "5w" or "1500w"

Exiting pota_rapidlog:

    To exit the program you can either press <CTRL-C> or type "exit" at any
    prompt. pota_rapidlog never leaves the log file open, so there is no
    danger to losing your data.

pota_rapidlog ADIF file:

    The ADIF file that pota_rapidlog generates adheres to the following POTA
    documentation:

https://docs.pota.app/docs/activator_reference/ADIF_for_POTA_reference.html

Installing pota_rapidlog:

    To install and run pota_rapidlog requires that Git and Python3 be installed
    on the host system. See your host system below for specific instructions.

    Chromebook:

        Newer Chromebooks run a version of Linux that have both Git and Python3
        pre-installed. Add low cost and long battery life to that advantage and
        the result is that they make an excellent platform on which to run
        pota_rapidlog in the field.

        Follow these instructions to enable Linux on your Chromebook:

            https://support.google.com/chromebook/answer/9145439

        If you can't find the "Linux development environment" under
        Settings->Advanced->Developers, your Chromebook may be too old to run
        Linux.

        Once you have setup Linux and started it, you will be at a terminal
        window. Issue the following two commands to setup pota_rapidlog (note
        that character case is important!):

            cd ~
            git clone https://github.com/roger-oakey/K0RLO.git

        This will create a "K0RLO" directory in your home directory. To run
        pota_rapidlog, type the following commands (note that character case is
        important!):

            cd ~/K0RLO
            ./pota_rapidlog

        ...and pota_rapidlog will start running and your log files will found
        in the same directory.

        From time to time to assure that you have the latest and greatest
        version of pota_rapidlog, type the following two commands:

            cd ~/K0RLO
            git pull

    Other Linux versions:

        There are too many versions of Linux around to document the setup
        process for them all. Just make sure both Git and Python3 are installed
        on your version of Linux, and then follow the Chromebook instructions,
        above, for installing and running pota_rapidlog.

    Windows:

        To be supplied.

*******************************************************************************
"""
    ]

####
#### Import support modules
####

import os
import re
import shutil
import sys
import time

comment_re = r'"[\ -\!\#-\~]*("|$)?'

####
#### Import large tables and help files to de-clutter the program
####

import k0rlo
import adif

#
#This is the order that the ADIF tags will be placed into the file for
#consistency
#
adif_tag_support_and_order = (
    "QSO_DATE",
    "TIME_ON",
    "STATION_CALLSIGN",
    "OPERATOR",
    "CALL",
    "BAND",
    "BAND_RX",
    "MODE",
    "SUBMODE",
    "MY_SIG",
    "MY_SIG_INFO",
    "MY_STATE",
    "SIG",
    "SIG_INFO",
    "RST_SENT",
    "RST_RCVD",
    "FREQ",
    "FREQ_RX",
    "TX_PWR",
    "RX_PWR",
    "COMMENT"
    )

band_tags = (
    "BAND",
    "BAND_RX"
    )

frequency_tags = (
    "FREQ",
    "FREQ_RX"
    )

power_tags = (
    "TX_PWR",
    "RX_PWR"
    )

rst_tags = (
    "RST_SENT",
    "RST_RCVD"
    )

mode_tags = (
    "MODE",
    "SUBMODE"
    )

####
#### Subroutines
####

def get_filename(callsign, park, state):
    """
    Generate full filename based on the callsign, park date and time and
    optional identification. Replace "/" in callsigns with "-"

    Arguments:
        callsign:   String containing operator callsign. May include "/".
        park:       String containing operator park ID
        state:      Optional state identification

    Returns:
        CallSign_Park[_state].adif
    """

    if state:
        state = "_" + state
    return(callsign.replace("/", "-") + "_" + park + state + adif.extension)

###############################################################################
###############################################################################
####
#### Start of main program
####
###############################################################################
###############################################################################

#
#Tell the user how to get help
#
print("""
Type "?" at any time to get help on the specific question being asked.
Type "HELP" at any time to get the complete documentation for pota_rapidlog.
""")

####
#### Ask what operator(s) are sharing this microphone
####

#
#Multiple operators may be specified if you're working with more than one
#operator at a radio. When a contact is made, it is possible to exclude
#an operator in case they're not available for that particular contact.
#

help[0] = """
Enter one or more operator callsigns (operators "sharing a microphone").
    Callsigns may include the "/" character.
    Examples: "K0RLO", "K0RLO W1JU" or "K0RLO/R1"
"""
while(True):
    operators = k0rlo.get_input(help, """
Operator callsign(s): """)["UPCASE"]
    #
    #Validate callsign format of all operators supplied
    #
    bad_callsign = False
    ops = {}
    for operator in re.split(k0rlo.default_split, operators):
        #
        #Save operator in dictonary to eliminate duplicates
        #
        ops[operator] = True
        #
        #Validate callsign
        #
        report_error = k0rlo.valid_callsign(operator)
        if report_error:
            print(report_error)
            bad_callsign = True

    #
    #If a bad callsign format was detected, ask the callsign question again
    #
    if not bad_callsign:
        break


#
#Save unique operators
#
operators = sorted(ops.keys())

####
#### Ask what park(s) are being activated
####

#
#Multiple parks may be specified so if you're in a park next to a national
#scenic trail, for example, you can log both at once.
#
help[0] = """
Enter one or more park codes. Multiple park codes are when you're activating
    multiple parks from one location.
    Examples: "K-1211" or "K-1211 K-1214"
"""
while(True):
    parks = k0rlo.get_input(help, """
Park code(s): """)["UPCASE"]

    #
    #Validate park format
    #
    bad_park = False
    pks = {}
    for park in re.split(k0rlo.default_split, parks):
        #
        #Save park in dictonary to eliminate duplicates
        #
        pks[park] = True
        #
        #See if park format correct
        #
        if not re.fullmatch(r'[A-Z]+-\d{4}', park):
            #
            #If a park identifier has a bad format, report it
            #
            print ("""
Error: "{}" is not a valid format for a park.
       It must be one or more letters, followed by a dash and then four digits.
       Examples: "K-1211" or "K-1214".
""".format(park))
            bad_park = True

    #
    #If a bad park format was detected, ask the park question again
    #
    if not bad_park:
        break

#
#Save unique parks
#
parks = sorted(pks.keys())

####
#### Ask for state
####

help[0] = """
Type <Enter> if no state is to be specified.
    Enter state or province identifier
    Examples: "CO" or "US-CO"
"""
while(True):
    #
    #Get optional state information that will be added at end of filename
    #
    state = k0rlo.get_input(help, """
State/province/etc. of activation [NONE]: """)["UPCASE"]

    #
    #If no state, get out of loop
    #
    if not state:
        break

    #
    #Validate state information
    #
    if re.fullmatch(r'[A-Z]+(-[A-Z]+|$)', state):
        #
        #We have the state
        #
        break

    #
    #Report error and ask again
    #
    print("""
Error: {} is not a valid state format. State/province/etc. must start and end
       with alphanumeric characters and can optionally contain one "-".
""".format(state))


####
#### Ask if this activation has a special event callsign
####

#
#Note: only one callsign allowed for a special event.
#
while(True):
    help[0] = """
Type <Enter> if this is not a special event.
    Enter the special event callsign.
    Examples: "W4W" or "W3MX"
"""
    special_event_callsign = k0rlo.get_input(help,
        """
Special event callsign [NONE]: """)["UPCASE"]

    #
    #If nothing entered, leave special_event_callsign blank
    #
    if not special_event_callsign:
        break

    #
    #Validate callsign of special event
    #
    report_error = k0rlo.valid_callsign(special_event_callsign, slash=False)
    if report_error:
        #
        #If invalid, report
        #
        print(report_error)
    else:
        break

####
#### See if this is a continuation of an existing log or if a new log should
#### be started.
####

#
#Determine filename(s) based on special event or not
#
if special_event_callsign:
    callsigns = [special_event_callsign]
else:
    callsigns = operators

help[0] = """
Enter "N" (or just press <Enter>) if you wish to continue to log hunter
    contacts in the existing file.
Enter "Y" if you wish to archive the existing log file (with the last modified
    date included in the extension) and start a new log file.
"""

for operator in callsigns:
    for park in parks:
        filename = get_filename(operator, park, state)
        #
        #If a log file by this name does not currently exist, keep looking
        #
        if not os.path.exists(filename):
            continue

        #
        #Get last modified time for this file and prompt if it should be archived
        #
        mtime = time.localtime(os.path.getmtime(filename))
        prompt = """
POTA log already exists for this callsign and park: {}
Last modified on {} (Local time)
Do you wish to archive it and start a new log""".format(filename,
            time.strftime("%Y/%m/%d %H:%M:%S", mtime))

        #
        #New log file to start, rename the old file
        #
        if k0rlo.get_yes_no(help, prompt, "N"):
            new_filename = filename + time.strftime("_%Y%m%d-%H%M%S", mtime)
            print("""
Renaming existing log file "{}" to "{}"
""".format(filename, new_filename))
            os.rename(filename, new_filename)


####
#### Get the operating frequency or band
####

while(True):
    help[0] = """
Enter the band or frequency. If you enter a frequency, the band will be
    automatically set.
    If split bands enter transmit band first, followed by the
    receive band.
    Examples: "20M", "70CM" or "40M 20M"
    Or, enter the transmit frequency. If split frequency enter transmit
    frequency first, followed by the receive frequency.
    Examples: "14.215" or "114.215 14.275"
"""
    freq = k0rlo.get_input(help, """
Band or frequency: """)["UPCASE"]

    #
    #Validate band or frequency
    #
    test = adif.valid_band(freq)
    if type(test) != str:
        bands = test
        frequencies = []
        break

    test = adif.valid_frequency(freq)
    if type(test) != str:
        (bands, frequencies) = test
        break

    #
    #Report error and ask again
    #
    print("""
Error: Incorrectly formatted band or frequency. Band should be entered as "20M"
       or "70CM" or frequency should be entered as "14.215". If split bands or
       frequencies, enter transmit band or frequency first,
       Examples:
           Band: "20M", "40M" or for split: "20M 40M".
           Frequency: "14.215", "14.275" or for split: "14.215 14.275"
""")

####
#### Get the operating mode
####

while(True):
    help[0] = """
Enter the QSO mode and, if desired, the submode. Note that you can specify JUST
    the submode and the mode will be determined.
    Examples: "CW", "SSB", "SSB USB", "LSB", "OLIVIA 4/125"
"""
    mode = k0rlo.get_input(help, """
Operating mode: """)["UPCASE"]

    #
    #Validate mode
    #
    test = adif.valid_mode(mode)
    if type(test) != str:
        mode_submode = test
        break

    #
    #Report error and ask again
    #
    print(test)

#
#Put a space before the first log entry
#
print("")

#
#Do not report power unless specified
#
power = ["0","0"]

#### Now log the hunters
####
#### At minimum you just need the callsign. The callsign must be
#### specified first.
####
#### Optionally you can supply one or more parks identifiers, RST (hunter's RST
#### followed by operator's RST) and the hunter's power output.
####
#### These fields can be intermingled - they'll be sorted out.
####
#### In addition, you can switch bands, frequencies, modes or transmit power
#### by just typing a band, mode, frequency or power alone on a line.
####

while (True):
    #
    #See if power is being reported
    #
    if power[0] != "0":
        display_power = power[0] + "W"
    else:
        display_power = "NOPWR"

    if len(mode_submode) > 1:
        display_mode = mode_submode[1]
    else:
        display_mode = mode_submode[0]

    #
    #Do not report hunter power unless specified in log entry
    #
    power[1] = "0"

    #
    #Get hunter information
    #
    help[0] = """
At this prompt you can do the following:
    Specify a new mode and optionally a submode, such as "CW" or "SSB USB".
    Specify a new band or transmit AND receive band, such as
        "20M" or "20M 40M".
        If you specify the band, no frequency will not be recorded.
    Specify a new frequency or transmit AND receive frequency, such as
        "14.215" or "14.215 14.275"
        If you specify the frequency, the band will be correctly set.
    Specify a new transmit power, such as "100W". Enter "0W" to stop recording
        a transmit power.

    Enter a hunter contact:
        Enter the hunter's callsign, followed by optional information in any
        order like sent and received RSTs, hunter transmit power, park to park
        identifier(s) and a comment enclosed in double quotes (or if the
        comment is at the end of the line, it only has to be started with a
        double quote - no need for a closing quote).

        All optional information may be entered in ANY order.
"""
    hunter_info = k0rlo.get_input(help, 
        "({}:{}:{}) Hunter contact information: ".format(bands[0],
            display_mode, display_power))

    original_hunter_info = hunter_info["ORIGINAL"]
    hunter_info = hunter_info["UPCASE"]

    #
    #See if new band(s) have been specified
    #
    test = adif.valid_band(hunter_info)
    if type(test) != str:
        #
        #Save both band and no frequencies
        #
        bands = test
        frequencies = []
        continue

    #
    #See ifnew frequency (-ies) have been specified
    #
    test = adif.valid_frequency(hunter_info)
    if type(test) != str:
        #
        #Save both band(s) and frequencies
        #
        (bands, frequencies) = test
        continue

    #
    #See if a new mode has been specified
    #
    test = adif.valid_mode(hunter_info)
    if type(test) != str:
        mode_submode = test
        continue

    #
    #See if a new power has been specified
    #
    test = adif.valid_power(hunter_info)
    if type(test) != str:
        #
        #Save new power. Setting power to "0" will cause no power to be
        #reported.
        #
        #Unpack tuple into activator power [0]
        #
        (power[0],) = test
        continue

    ####
    #### Looks like we have a contact to log, log it
    ####

    #
    #Default to no comment
    #
    comment = ""

    #
    #See if a comment has been specified
    #
    quotes = original_hunter_info.count('"')
    if quotes:
        #
        #There is a comment to be logged. Handle one or two quotes
        #
        if quotes > 2:
            #
            #More than two double quotes, that's an error
            #
            print("""
Error: More than two double quotes '"' detected. A comment must have two double
       quotes surrounding it, or start with a single double quote if at the end
       of the line.
""")
            continue

        #
        #Pull out comment from opening quote to closing quote or EOL (re $)
        #
        comment = re.search(comment_re, original_hunter_info)[0][1:]
        hunter_info = re.sub(comment_re, " ", hunter_info).strip()

        #
        #Remove closing quote if necessary
        #
        if quotes > 1:
            comment = comment[0:-1].strip()

    #
    #Get the current GMT now so all logs for this hunter show
    #the same time.
    #
    utc = time.gmtime()

    #
    #Split input line to see if this is just a hunter (only character
    #string) or RST reports and/or a park-to-park which will specify
    #the park as following character strings.
    #
    hunter_info = re.split(k0rlo.default_split, hunter_info)

    #
    #Get the hunter callsign which is the first (and perhaps
    #only) contents of the list. Parks and RSTs (if any) remain.
    #
    hunter_callsign = hunter_info.pop(0)

    #
    #Start off with checking if it's a bad callsign
    #
    report_error = k0rlo.valid_callsign(hunter_callsign)
    if report_error:
        print(report_error)

    #
    #Initialize bad_info based upon the validation of the callsign
    #
    bad_entry = bool(report_error)

    #
    #Split the remainder of the info into RST reports and parks, if any
    #
    hunter_parks = {}
    hunter_power = {}
    rst = []
    bad_strings = []

    #
    #Look through the free-float format and save optional park, RST and power,
    #if any. Report anything that doesn't match as an error.
    #
    for component in hunter_info:
        #
        #If it's a park, save it as a park
        #
        if re.fullmatch(r'[A-Z]+-\d{4}', component):
            #
            #Eliminate duplicate parks by using dictonary
            #
            hunter_parks[component] = True
            continue
        #
        #If it's an RST, save it as an RST
        #
        if re.fullmatch(r'[1-5][1-9]{1,2}', component):
            #
            #It's an RST number, save it as an RST
            #
            rst.append(component)
            continue
        #
        #If it's a power, save it as a power
        #
        if re.fullmatch(r'\d{1,4}W', component):
            #
            #It's an hunter power, save it as an power removing the "W"
            #
            hunter_power[component] = True
            continue

        #
        #Unrecognized string, save error
        #
        bad_strings.append(component)
        bad_entry = True

    #
    #Verify we have no more than one power entry.
    #
    if hunter_power:
        if len(hunter_power) > 1:
            print("""
Error: More than one power entry. The hunter can only have one power entered.
""")
            bad_entry = True
        #
        #Save receive power - only one entry in the dictonary, get its key
        #and strip the "W" off the end.
        #
        power[1] = list(hunter_power)[0][:-1]


    #
    #Verify we have no more than 2 RST entries
    #
    if len(rst) > 2:
        print("""
Error: More than two RST entries. The RST report you send to the hunter is the
       first RST report, the second RST is what the hunter reports to you.
       Examples: "59", "589" or "59 59".
""")
        #
        #Ask for all the info again
        #
        bad_entry = True

    #
    #Report any strings we didn't recognize
    #
    for errors in bad_strings:
        #
        #Report error
        #
        print("""
Error: "{}" is not a recognized entry. Press <Enter> to get help on how to
       enter information on the hunter contact information line.
""".format(errors))
        bad_entry = True
    #
    #If we got any bad information, skip processing and ask for
    #hunter callsign, RST and park(s) again.
    #
    if bad_entry:
        continue

    ####
    #### Start assembling the record to be logged, start with the stuff
    #### common to all the record(s) to be written. Start with a ADIF record
    #### only containing MY_SIG = POTA
    ####
    log_record = {"MY_SIG":"POTA"}

    #
    #Save the date, time and hunter callsign
    #
    log_record["QSO_DATE"] = time.strftime("%Y%m%d", utc)
    log_record["TIME_ON"] = time.strftime("%H%M%S", utc)
    log_record["CALL"] = hunter_callsign

    #
    #Save transmit, and optionally receive band in record
    #
    for index in range(len(bands)):
        log_record[band_tags[index]] = bands[index]

    #
    #Save mode and submode
    #
    for index in range(len(mode_submode)):
        log_record[mode_tags[index]] = mode_submode[index]

    #
    #Save transmit, and optionally receive frequencies in record
    #
    for index in range(len(frequencies)):
        log_record[frequency_tags[index]] = frequencies[index]

    #
    #Save optional transmit and receive power in record
    #
    for index in range(len(power)):
        if power[index] != "0":
            #
            #If there is a power specified, report it
            #
            log_record[power_tags[index]] = power[index]

    #
    #Save sent and received RST, if specified
    #
    for index in range(len(rst)):
        log_record[rst_tags[index]] = rst[index]

    #
    #Save state if specified
    #
    if state:
        log_record["MY_STATE"] = state

    #
    #Save comment if specified
    #
    if comment:
        log_record["COMMENT"] = comment

    #
    #Log contacts for all operators (any input will skip an
    #operator from having a log entry)
    #
    help[0] = """
Enter "Y" (or just press <Enter>) if the specified operator has performed an
    exchange with the hunter and they wish to receive credit for the contact.
Enter "N" if the specified operator is unable to perform an exchange with
    the hunter or they should not receive credit for the contact.
"""
    for operator in operators:
        if ((len(operators) > 1) and
            not k0rlo.get_yes_no(help, "Log contact for " + operator, "Y")):
            #
            #If "N" typed, skip this operator
            #
            continue

        #
        #Now write a file for each park we're at
        #
        for park in parks:
            #
            #Determine filename based on special_event_callsign or not
            #
            if special_event_callsign:
                log_record["STATION_CALLSIGN"] = special_event_callsign
                log_record["OPERATOR"] = operator
            else:
                log_record["STATION_CALLSIGN"] = operator

            #
            #Filename is always based on the STATION_CALLSIGN
            #
            log_filename = get_filename(log_record["STATION_CALLSIGN"], park, state)

            #
            #We've waited until we REALLY need to create a log file, time to
            #see if we need to create the file and write the header
            #
            if not os.path.exists(log_filename):
                #
                #If this log file does not yet exist, create a header
                #
                f = open(log_filename, "w")
                f.write(("Parks On The Air (POTA) rapid log\n" +
                    adif.tag("PROGRAMID", "pota_rapidlog") + "\n" +
                    adif.tag("PROGRAMVERSION", pota_rapidlog_version) +
                    "\n" +
                    adif.tag("CREATED_TIMESTAMP",
                        time.strftime("%Y%m%d %H%M%S", utc)) +
                        "<EOH>\n"))
                f.close()

            #
            #Add this park to the record to be written
            #
            log_record["MY_SIG_INFO"] = park

            if hunter_parks:
                #
                #We have one or more park-to-park contacts to log, open
                #the file and write [perhaps] multiple records
                #
                f = open(log_filename, "a")
                #
                #We're writing Park to park information, so setup the SIG
                log_record["SIG"] = "POTA"

                #
                #Now write records for all park to park parks
                #
                for hunter_park in sorted(hunter_parks.keys()):
                    #
                    #This is a park to park, fill in the addiitional
                    #information
                    #
                    log_record["SIG_INFO"] = hunter_park
                    f.write(adif.record(log_record, adif_tag_support_and_order))
                #
                #Keep the file closed to avoid dataloss
                #
                f.close()
            else:
                #
                #No park to park, write the record for this normal hunter
                #contact
                #
                f = open(log_filename, "a")
                f.write(adif.record(log_record, adif_tag_support_and_order))
                #
                #Keep the file closed to avoid dataloss
                #
                f.close()

exit()
