#!/usr/bin/python3

###############################################################################
###############################################################################
####
#### Simple POTA logging program that allows freeform input of contacts
####
###############################################################################
###############################################################################

####
#### Global definitions
####

rapid_logger_version = "1"

help = [
    None,
    """
Replace with program help text
"""
    ]

####
#### Import support modules
####

import os
import re
import shutil
import sys
import time

#print(sys.argv)

####
#### Import large tables and help files to de-clutter the program
####

import k0rlo
import adif

#
#This is the order that the ADIF tags will be placed into the file for
#consistency
#
adif_tag_support_and_order = (
    "QSO_DATE",
    "TIME_ON",
    "STATION_CALLSIGN",
    "OPERATOR",
    "CALL",
    "BAND",
    "BAND_RX",
    "MODE",
    "SUBMODE",
    "MY_SIG",
    "MY_SIG_INFO",
    "MY_STATE",
    "SIG",
    "SIG_INFO",
    "RST_SENT",
    "RST_RCVD",
    "FREQ",
    "FREQ_RX",
    "TX_PWR",
    "RX_PWR"
    )

band_tags = (
    "BAND",
    "BAND_RX"
    )

frequency_tags = (
    "FREQ",
    "FREQ_RX"
    )

power_tags = (
    "TX_PWR",
    "RX_PWR"
    )

rst_tags = (
    "RST_SENT",
    "RST_RCVD"
    )

mode_tags = (
    "MODE",
    "SUBMODE"
    )

####
#### Subroutines
####

def get_filename(callsign, park, state):
    """
    Generate full filename based on the callsign, park date and time and
    optional identification. Replace "/" in callsigns with "-"

    Arguments:
        callsign:   String containing operator callsign. May include "/".
        park:       String containing operator park ID
        state:      Optional state identification

    Returns:
        CallSign_Park[_state].adif
    """

    if state:
        state = "_" + state
    return(callsign.replace("/", "-") + "_" + park + state + adif.extension)

###############################################################################
###############################################################################
####
#### Start of main program
####
###############################################################################
###############################################################################

####
#### Ask what operator(s) are sharing this microphone
####

#
#Multiple operators may be specified if you're working with more than one
#operator at a radio. When a contact is made, it is possible to exclude
#an operator in case they're not available for that particular contact.
#

help[0] = """
Enter one or more operator callsigns (operators "sharing a microphone").
    Callsigns may include the "/" character.
    Examples: "K0RLO", "K0RLO W1JU" or "K0RLO/R1"
"""
while(True):
    operators = k0rlo.get_input(help, "Operator callsign(s): ")
    #
    #Validate callsign format of all operators supplied
    #
    bad_callsign = False
    ops = {}
    for operator in re.split(k0rlo.default_split, operators):
        #
        #Save operator in dictonary to eliminate duplicates
        #
        ops[operator] = True
        #
        #Validate callsign
        #
        report_error = k0rlo.valid_callsign(operator)
        if report_error:
            print(report_error)
            bad_callsign = True

    #
    #If a bad callsign format was detected, ask the callsign question again
    #
    if not bad_callsign:
        break

#
#Save unique operators
#
operators = sorted(ops.keys())

####
#### Ask what park(s) are being activated
####

#
#Multiple parks may be specified so if you're in a park next to a national
#scenic trail, for example, you can log both at once.
#
help[0] = """
Enter one or more park codes. Multiple park codes are when you're activating
    multiple parks from one location.
    Examples: "K-1211" or "K-1211 K-1214"
"""
while(True):
    parks = k0rlo.get_input(help, "Park code(s): ")

    #
    #Validate park format
    #
    bad_park = False
    pks = {}
    for park in re.split(k0rlo.default_split, parks):
        #
        #Save park in dictonary to eliminate duplicates
        #
        pks[park] = True
        #
        #See if park format correct
        #
        if not re.fullmatch(r'[A-Z]+-\d{4}', park):
            #
            #If a park identifier has a bad format, report it
            #
            print ("""
Error: "{}" is not a valid format for a park.
       It must be one or more letters, followed by a dash and then four digits.
       Examples: "K-1211" or "K-1214".
""".format(park))
            bad_park = True

    #
    #If a bad park format was detected, ask the park question again
    #
    if not bad_park:
        break

#
#Save unique parks
#
parks = sorted(pks.keys())

####
#### Ask for state
####

help[0] = """
Type <Enter> if no state is to be specified.
    Enter state or province identifier
    Examples: "CO" or "US-CO"
"""
while(True):
    #
    #Get optional state information that will be added at end of filename
    #
    state = k0rlo.get_input(help, 'State/province/etc. of activation [NONE]: ')

    #
    #If no state, get out of loop
    #
    if not state:
        break

    #
    #Validate state information
    #
    if re.fullmatch(r'[A-Z]+(-[A-Z]+|$)', state):
        #
        #We have the state
        #
        break

    #
    #Report error and ask again
    #
    print("""
Error: {} is not a valid state format. State/province/etc. must start and end
       with alphanumeric characters and can optionally contain one "-".
""".format(state))


####
#### Ask if this activation has a special event callsign
####

#
#Note: only one callsign allowed for a special event.
#
while(True):
    help[0] = """
Type <Enter> if this is not a special event.
    Enter the special event callsign.
    Examples: "W4W" or "W3MX"
"""
    special_event_callsign = k0rlo.get_input(help,
        'Special event callsign [NONE]: ')

    #
    #If nothing entered, leave special_event_callsign blank
    #
    if not special_event_callsign:
        break

    #
    #Validate callsign of special event
    #
    report_error = k0rlo.valid_callsign(special_event_callsign, slash=False)
    if report_error:
        #
        #If invalid, report
        #
        print(report_error)
    else:
        break

####
#### See if this is a continuation of an existing log or if a new log should
#### be started.
####

#
#Determine filename(s) based on special event or not
#
if special_event_callsign:
    callsigns = [special_event_callsign]
else:
    callsigns = operators

help[0] = """
Enter "N" (or just press <Enter>) if you wish to continue to log hunter
    contacts in the existing file.
Enter "Y" if you wish to archive the existing log file (with the last modified
    date included in the extension) and start a new log file.
"""

for operator in callsigns:
    for park in parks:
        filename = get_filename(operator, park, state)
        #
        #If a log file by this name does not currently exist, keep looking
        #
        if not os.path.exists(filename):
            continue

        #
        #Get last modified time for this file and prompt if it should be archived
        #
        mtime = time.localtime(os.path.getmtime(filename))
        prompt = """
POTA log already exists for this callsign and park: {}
Last modified on {} (Local time)
Do you wish to archive it and start a new log""".format(filename,
            time.strftime("%Y/%m/%d %H:%M:%S", mtime))

        #
        #New log file to start, rename the old file
        #
        if k0rlo.get_yes_no(help, prompt, "N"):
            new_filename = filename + time.strftime("_%Y%m%d-%H%M%S", mtime)
            print("""
Renaming existing log file "{}" to "{}"
""".format(filename, new_filename))
            os.rename(filename, new_filename)


####
#### Get the operating frequency or band
####

while(True):
    help[0] = """
Enter the band or frequency. If you enter a frequency, the band will be
    automatically set.
    If split bands enter transmit band first, followed by the
    receive band.
    Examples: "20M", "70CM" or "40M 20M"
    Or, enter the transmit frequency. If split frequency enter transmit
    frequency first, followed by the receive frequency.
    Examples: "14.215" or "114.215 14.275"
"""
    freq = k0rlo.get_input(help, "Band or frequency: ")

    #
    #Validate band or frequency
    #
    test = adif.valid_band(freq)
    if type(test) != str:
        bands = test
        frequencies = []
        break

    test = adif.valid_frequency(freq)
    if type(test) != str:
        (bands, frequencies) = test
        break

    #
    #Report error and ask again
    #
    print("""
Error: Incorrectly formatted band or frequency. Band should be entered as "20M"
       or "70CM" or frequency should be entered as "14.215". If split bands or
       frequencies, enter transmit band or frequency first,
       Examples:
           Band: "20M", "40M" or for split: "20M 40M".
           Frequency: "14.215", "14.275" or for split: "14.215 14.275"
""")

####
#### Get the operating mode
####

while(True):
    help[0] = """
Enter the QSO mode and, if desired, the submode. Note that you can specify JUST
    the submode and the mode will be determined.
    Examples: "CW", "SSB", "SSB USB", "LSB", "OLIVIA 4/125"
"""
    mode = k0rlo.get_input(help, "Operating mode: ")

    #
    #Validate mode
    #
    test = adif.valid_mode(mode)
    if type(test) != str:
        mode_submode = test
        break

    #
    #Report error and ask again
    #
    print(test)

#
#Do not report power unless specified
#
power = ["0","0"]

#### Now log the hunters
####
#### At minimum you just need the callsign. The callsign must be
#### specified first.
####
#### Optionally you can supply one or more parks identifiers, RST (hunter's RST
#### followed by operator's RST) and the hunter's power output.
####
#### These fields can be intermingled - they'll be sorted out.
####
#### In addition, you can switch bands, frequencies, modes or transmit power
#### by just typing a band, mode, frequency or power alone on a line.
####

while (True):
    #
    #See if power is being reported
    #
    if power[0] != "0":
        display_power = power[0] + "W"
    else:
        display_power = "NOPWR"

    if len(mode_submode) > 1:
        display_mode = mode_submode[1]
    else:
        display_mode = mode_submode[0]

    #
    #Do not report hunter power unless specified in log entry
    #
    power[1] = "0"

    #
    #Get hunter information
    #
    help[0] = """
At this prompt you can do the following:
    Specify a new mode and optionally a submode, such as "CW" or "SSB USB".
    Specify a new band or transmit AND receive band, such as
        "20M" or "20M 40M".
        If you specify the band, no frequency will not be recorded.
    Specify a new frequency or transmit AND receive frequency, such as
        "14.215" or "14.215 14.275"
        If you specify the frequency, the band will be correctly set.
    Specify a new transmit power, such as "100W". Enter "0W" to stop recording
        a transmit power.

    Enter a hunter contact:
        Enter the hunter's callsign, followed by optional information like sent
        and received RSTs, hunter transmit power and park to park
        identifier(s).

        All optional information may be entered in ANY order.
"""
    hunter_info = k0rlo.get_input(help, 
"({}:{}:{}) Hunter contact information: ".format(bands[0], display_mode,
        display_power))

    #
    #See if new band(s) have been specified
    #
    test = adif.valid_band(hunter_info)
    if type(test) != str:
        #
        #Save both band and no frequencies
        #
        bands = test
        frequencies = []
        continue

    #
    #See ifnew frequency (-ies) have been specified
    #
    test = adif.valid_frequency(hunter_info)
    if type(test) != str:
        #
        #Save both band(s) and frequencies
        #
        (bands, frequencies) = test
        continue

    #
    #See if a new mode has been specified
    #
    test = adif.valid_mode(hunter_info)
    if type(test) != str:
        mode_submode = test
        continue

    #
    #See if a new power has been specified
    #
    test = adif.valid_power(hunter_info)
    if type(test) != str:
        #
        #Save new power. Setting power to "0" will cause no power to be
        #reported.
        #
        #Unpack tuple into activator power [0]
        #
        (power[0],) = test
        continue

    ####
    #### Looks like we have a contact to log, log it
    ####

    #
    #Get the current GMT now so all logs for this hunter show
    #the same time.
    #
    utc = time.gmtime()

    #
    #Split input line to see if this is just a hunter (only character
    #string) or RST reports and/or a park-to-park which will specify
    #the park as following character strings.
    #
    hunter_info = re.split(k0rlo.default_split, hunter_info)

    #
    #Get the hunter callsign which is the first (and perhaps
    #only) contents of the list. Parks and RSTs (if any) remain.
    #
    hunter_callsign = hunter_info.pop(0)

    #
    #Start off with checking if it's a bad callsign
    #
    report_error = k0rlo.valid_callsign(hunter_callsign)
    if report_error:
        print(report_error)

    #
    #Initialize bad_info based upon the validation of the callsign
    #
    bad_entry = bool(report_error)

    #
    #Split the remainder of the info into RST reports and parks, if any
    #
    hunter_parks = {}
    hunter_power = {}
    rst = []
    bad_strings = []

    #
    #Look through the free-float format and save optional park, RST and power,
    #if any. Report anything that doesn't match as an error.
    #
    for component in hunter_info:
        #
        #If it's a park, save it as a park
        #
        if re.fullmatch(r'[A-Z]+-\d{4}', component):
            #
            #Eliminate duplicate parks by using dictonary
            #
            hunter_parks[component] = True
            continue
        #
        #If it's an RST, save it as an RST
        #
        if re.fullmatch(r'[1-5][1-9]{1,2}', component):
            #
            #It's an RST number, save it as an RST
            #
            rst.append(component)
            continue
        #
        #If it's a power, save it as a power
        #
        if re.fullmatch(r'\d{1,4}W', component):
            #
            #It's an hunter power, save it as an power removing the "W"
            #
            hunter_power[component] = True
            continue

        #
        #Unrecognized string, save error
        #
        bad_strings.append(component)
        bad_entry = True

    #
    #Verify we have no more than one power entry.
    #
    if hunter_power:
        if len(hunter_power) > 1:
            print("""
Error: More than one power entry. The hunter can only have one power entered.
""")
            bad_entry = True
        #
        #Save receive power - only one entry in the dictonary, get its key
        #and strip the "W" off the end.
        #
        power[1] = list(hunter_power)[0][:-1]


    #
    #Verify we have no more than 2 RST entries
    #
    if len(rst) > 2:
        print("""
Error: More than two RST entries. The RST report you send to the hunter is the
       first RST report, the second RST is what the hunter reports to you.
       Examples: "59", "589" or "59 59".
""")
        #
        #Ask for all the info again
        #
        bad_entry = True

    #
    #Report any strings we didn't recognize
    #
    for errors in bad_strings:
        #
        #Report error
        #
        print("""
Error: "{}" is not a recognized entry. Press <Enter> to get help on how to
       enter information on the hunter contact information line.
""".format(errors))
        bad_entry = True
    #
    #If we got any bad information, skip processing and ask for
    #hunter callsign, RST and park(s) again.
    #
    if bad_entry:
        continue

    ####
    #### Start assembling the record to be logged, start with the stuff
    #### common to all the record(s) to be written. Start with a ADIF record
    #### only containing MY_SIG = POTA
    ####
    log_record = {"MY_SIG":"POTA"}

    #
    #Save the date, time and hunter callsign
    #
    log_record["QSO_DATE"] = time.strftime("%Y%m%d", utc)
    log_record["TIME_ON"] = time.strftime("%H%M%S", utc)
    log_record["CALL"] = hunter_callsign

    #
    #Save transmit, and optionally receive band in record
    #
    for index in range(len(bands)):
        log_record[band_tags[index]] = bands[index]

    #
    #Save mode and submode
    #
    for index in range(len(mode_submode)):
        log_record[mode_tags[index]] = mode_submode[index]

    #
    #Save transmit, and optionally receive frequencies in record
    #
    for index in range(len(frequencies)):
        log_record[frequency_tags[index]] = frequencies[index]

    #
    #Save optional transmit and receive power in record
    #
    for index in range(len(power)):
        if power[index] != "0":
            #
            #If there is a power specified, report it
            #
            log_record[power_tags[index]] = power[index]

    #
    #Save sent and received RST, if specified
    #
    for index in range(len(rst)):
        log_record[rst_tags[index]] = rst[index]

    #
    #Save state if specified
    #
    if state:
        log_record["MY_STATE"] = state

    #
    #Log contacts for all operators (any input will skip an
    #operator from having a log entry)
    #
    help[0] = """
Enter "Y" (or just press <Enter>) if the specified operator has performed an
    exchange with the hunter and they wish to receive credit for the contact.
Enter "N" if the specified operator is unable to perform an exchange with
    the hunter or they should not receive credit for the contact.
"""
    for operator in operators:
        if ((len(operators) > 1) and
            not k0rlo.get_yes_no(help, "Log contact for " + operator, "Y")):
            #
            #If "N" typed, skip this operator
            #
            continue

        #
        #Now write a file for each park we're at
        #
        for park in parks:
            #
            #Determine filename based on special_event_callsign or not
            #
            if special_event_callsign:
                log_record["STATION_CALLSIGN"] = special_event_callsign
                log_record["OPERATOR"] = operator
            else:
                log_record["STATION_CALLSIGN"] = operator

            #
            #Filename is always based on the STATION_CALLSIGN
            #
            log_filename = get_filename(log_record["STATION_CALLSIGN"], park, state)

            #
            #We've waited until we REALLY need to create a log file, time to
            #see if we need to create the file and write the header
            #
            if not os.path.exists(log_filename):
                #
                #If this log file does not yet exist, create a header
                #
                f = open(log_filename, "w")
                f.write(("Parks On The Air (POTA) rapid logger\n" +
                    adif.tag("PROGRAMID", "POTA rapid logger") + "\n" +
                    adif.tag("PROGRAMVERSION", rapid_logger_version) +
                    "\n" +
                    adif.tag("CREATED_TIMESTAMP",
                        time.strftime("%Y%m%d %H%M%S", utc)) +
                        "<EOH>\n"))
                f.close()

            #
            #Add this park to the record to be written
            #
            log_record["MY_SIG_INFO"] = park

            if hunter_parks:
                #
                #We have one or more park-to-park contacts to log, open
                #the file and write [perhaps] multiple records
                #
                f = open(log_filename, "a")
                #
                #We're writing Park to park information, so setup the SIG
                log_record["SIG"] = "POTA"

                #
                #Now write records for all park to park parks
                #
                for hunter_park in sorted(hunter_parks.keys()):
                    #
                    #This is a park to park, fill in the addiitional
                    #information
                    #
                    log_record["SIG_INFO"] = hunter_park
                    f.write(adif.record(log_record, adif_tag_support_and_order))
                #
                #Keep the file closed to avoid dataloss
                #
                f.close()
            else:
                #
                #No park to park, write the record for this normal hunter
                #contact
                #
                f = open(log_filename, "a")
                f.write(adif.record(log_record, adif_tag_support_and_order))
                #
                #Keep the file closed to avoid dataloss
                #
                f.close()

exit()
