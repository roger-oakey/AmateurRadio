#!/usr/bin/python3

###############################################################################
###############################################################################
####
#### Simple POTA logging program that allows freeform input of contacts
####
###############################################################################
###############################################################################

####
#### Global definitions
####

pota_rapidlog_version = "2022/09/04"

####
#### Import support modules
####

import os
import re
import shutil
import sys
import time

comment_re = r'"[\ -\!\#-\~]*("|$)?'

####
#### Import large tables and help files to de-clutter the program
####

import k0rlo
import adif

#
#This is the order that the ADIF tags will be placed into the file for
#consistency
#
adif_tag_support_and_order = (
    "QSO_DATE",
    "TIME_ON",
    "STATION_CALLSIGN",
    "OPERATOR",
    "CALL",
    "BAND",
    "BAND_RX",
    "MODE",
    "SUBMODE",
    "MY_SIG",
    "MY_SIG_INFO",
    "MY_STATE",
    "SIG",
    "SIG_INFO",
    "RST_SENT",
    "RST_RCVD",
    "FREQ",
    "FREQ_RX",
    "TX_PWR",
    "RX_PWR",
    "COMMENT"
    )

band_tags = (
    "BAND",
    "BAND_RX"
    )

frequency_tags = (
    "FREQ",
    "FREQ_RX"
    )

power_tags = (
    "TX_PWR",
    "RX_PWR"
    )

rst_tags = (
    "RST_SENT",
    "RST_RCVD"
    )

mode_tags = (
    "MODE",
    "SUBMODE"
    )

####
#### Subroutines
####

def determine_filename(callsign, park, state):
    """
    Generate full filename based on the callsign, park date and time and
    optional identification. Replace "/" in callsigns with "-"

    Arguments:
        callsign:   String containing operator callsign. May include "/".
        park:       String containing operator park ID
        state:      Optional state identification

    Returns:
        CallSign_Park[_state].adif
    """

    if state:
        state = "_" + state
    return(callsign.replace("/", "-") + "_" + park + state + adif.extension)

###############################################################################
###############################################################################
####
#### Start of main program
####
###############################################################################
###############################################################################

#
#Tell the user how to get help
#
print("""
Type "?" at any time to get help on the specific question being asked.
Type "HELP" at any time to get the complete documentation for pota_rapidlog.
""")

####
#### Ask what operator(s) are sharing this microphone
####

#
#Multiple operators may be specified if you're working with more than one
#operator at a radio. When a contact is made, it is possible to exclude
#an operator in case they're not available for that particular contact.
#

help = """
Enter one or more operator callsigns (operators "sharing a microphone").
    Callsigns may include the "/" character.
    Examples: "K0RLO", "K0RLO W1JU" or "K0RLO/R1"
"""
while(True):
    operators = k0rlo.get_input(help, """
Operator callsign(s): """).upper()
    #
    #Validate callsign format of all operators supplied
    #
    bad_callsign = False
    ops = {}
    for operator in re.split(k0rlo.default_split, operators):
        #
        #Save operator in dictonary to eliminate duplicates
        #
        ops[operator] = True
        #
        #Validate callsign
        #
        report_error = k0rlo.valid_callsign(operator)
        if report_error:
            print(report_error)
            bad_callsign = True

    #
    #If a bad callsign format was detected, ask the callsign question again
    #
    if not bad_callsign:
        break


#
#Save unique operators
#
operators = sorted(ops.keys())

####
#### Ask what park(s) are being activated
####

#
#Multiple parks may be specified so if you're in a park next to a national
#scenic trail, for example, you can log both at once.
#
help = """
Enter one or more park codes. Multiple park codes are when you're activating
    multiple parks from one location.
    Examples: "K-1211" or "K-1211 K-1214"
"""
while(True):
    parks = k0rlo.get_input(help, """
Park code(s): """).upper()

    #
    #Validate park format
    #
    bad_park = False
    pks = {}
    for park in re.split(k0rlo.default_split, parks):
        #
        #Save park in dictonary to eliminate duplicates
        #
        pks[park] = True
        #
        #See if park format correct
        #
        if not re.fullmatch(r'[A-Z]+-\d{4}', park):
            #
            #If a park identifier has a bad format, report it
            #
            print ("""
Error: "{}" is not a valid format for a park.
       It must be one or more letters, followed by a dash and then four digits.
       Examples: "K-1211" or "K-1214".
""".format(park))
            bad_park = True

    #
    #If a bad park format was detected, ask the park question again
    #
    if not bad_park:
        break

#
#Save unique parks
#
parks = sorted(pks.keys())

####
#### Ask for state
####

help = """
Type <Enter> if no state is to be specified.
    Enter country and state identifier
    Note: US states and territories are verified, everything else is accepted
    as-is.
    Examples: "US-CO" or "US-MP"
"""
while(True):
    #
    #Get optional state information that will be added at end of filename
    #
    state = k0rlo.get_input(help, """
State/province/etc. of activation [None specified]: """).upper()

    #
    #If no state, get out of loop
    #
    if not state:
        break

    #
    #See if this is a known country and if so, check its state or province to
    #assure it's valid.
    #
    state_split = re.split(r'[\s-]+', state)
    if state_split[0] in adif.state_enumeration:
        if len(state_split) != 2:
            print("""
Error: You must specify a country-state or country-province for an activation.
""")
            continue

        #
        #Make it easier to handle the two
        #
        (country, state) = state_split
        #
        #See if this state or province is valid within this country
        #
        if state in adif.state_enumeration[country]:
            #
            #Reassemble country and state and use it for logging
            #
            state = country + "-" + state
            break

        print("""          
Error: "{}" is not a valid state or province for within country "{}"
""".format(state_split[1], state_split[0]))
        continue

    #
    #If we can't validate it, just accept whatever the person types
    #
    break

####
#### Ask if this activation has a special event callsign
####

#
#Note: only one callsign allowed for a special event.
#
while(True):
    help = """
Type <Enter> if this is not a special event.
    Enter the special event callsign.
    Examples: "W4W" or "W3MX"
"""
    special_event_callsign = k0rlo.get_input(help,
        """
Special event callsign [NONE]: """).upper()

    #
    #If nothing entered, leave special_event_callsign blank
    #
    if not special_event_callsign:
        break

    #
    #Validate callsign of special event
    #
    report_error = k0rlo.valid_callsign(special_event_callsign, slash=False)
    if report_error:
        #
        #If invalid, report
        #
        print(report_error)
    else:
        break

####
#### See if this is a continuation of an existing log or if a new log should
#### be started.
####

#
#Determine filename(s) based on special event or not
#
if special_event_callsign:
    callsigns = [special_event_callsign]
else:
    callsigns = operators

help = """
Enter "N" (or just press <Enter>) if you wish to continue to log hunter
    contacts in the existing file.
Enter "Y" if you wish to archive the existing log file (with the last modified
    date included in the extension) and start a new log file.
"""

for operator in callsigns:
    for park in parks:
        filename = determine_filename(operator, park, state)
        #
        #If a log file by this name does not currently exist, keep looking
        #
        if not os.path.exists(filename):
            continue

        #
        #Get last modified time for this file and prompt if it should be archived
        #
        mtime = time.localtime(os.path.getmtime(filename))
        prompt = """
POTA log already exists for this callsign and park: {}
Last modified on {} (Local time)
Do you wish to archive it and start a new log""".format(filename,
            time.strftime("%Y/%m/%d %H:%M:%S", mtime))

        #
        #New log file to start, rename the old file
        #
        if k0rlo.get_yes_no(help, prompt, "N"):
            new_filename = filename + time.strftime("_%Y%m%d-%H%M%S", mtime)
            print("""
Renaming existing log file "{}" to "{}"
""".format(filename, new_filename))
            os.rename(filename, new_filename)


####
#### Get the operating frequency or band
####

while(True):
    help = """
Enter the band or frequency. If you enter a frequency, the band will be
    automatically set.
    If split bands enter transmit band first, followed by the
    receive band.
    Examples: "20M", "70CM" or "40M 20M"
    Or, enter the transmit frequency. If split frequency enter transmit
    frequency first, followed by the receive frequency.
    Examples: "14.215" or "114.215 14.275"
"""
    freq = k0rlo.get_input(help, """
Band or frequency: """).upper()

    #
    #Validate band or frequency
    #
    test = adif.valid_band(freq)
    if type(test) != str:
        bands = test
        frequencies = []
        break

    test = adif.valid_frequency(freq)
    if type(test) != str:
        (bands, frequencies) = test
        break

    #
    #Report error and ask again
    #
    print("""
Error: Incorrectly formatted band or frequency. Band should be entered as "20M"
       or "70CM" or frequency should be entered as "14.215". If split bands or
       frequencies, enter transmit band or frequency first,
       Examples:
           Band: "20M", "40M" or for split: "20M 40M".
           Frequency: "14.215", "14.275" or for split: "14.215 14.275"
""")

####
#### Get the operating mode
####

while(True):
    help = """
Enter the QSO mode and, if desired, the submode. Note that you can specify JUST
    the submode and the mode will be determined.
    Examples: "CW", "SSB", "SSB USB", "LSB", "OLIVIA 4/125"
"""
    mode = k0rlo.get_input(help, """
Operating mode: """).upper()

    #
    #Validate mode
    #
    test = adif.valid_mode(mode)
    if type(test) != str:
        mode_submode = test
        break

    #
    #Report error and ask again
    #
    print(test)

#
#Put a space before the first log entry
#
print("")

#
#Do not report power unless specified
#
power = ["0","0"]

#### Now log the hunters
####
#### At minimum you just need the callsign. The callsign must be
#### specified first.
####
#### Optionally you can supply one or more parks identifiers, RST (hunter's RST
#### followed by operator's RST) and the hunter's power output.
####
#### These fields can be intermingled - they'll be sorted out.
####
#### In addition, you can switch bands, frequencies, modes or transmit power
#### by just typing a band, mode, frequency or power alone on a line.
####

while (True):
    #
    #See if power is being reported
    #
    if power[0] != "0":
        display_power = power[0] + "W"
    else:
        display_power = "NOPWR"

    if len(mode_submode) > 1:
        display_mode = mode_submode[1]
    else:
        display_mode = mode_submode[0]

    #
    #Do not report hunter power unless specified in log entry
    #
    power[1] = "0"

    #
    #Get hunter information
    #
    help = """
At this prompt you can do the following:
    Specify a new mode and optionally a submode, such as "CW" or "SSB USB".
    Specify a new band or transmit AND receive band, such as
        "20M" or "20M 40M".
        If you specify the band, no frequency will not be recorded.
    Specify a new frequency or transmit AND receive frequency, such as
        "14.215" or "14.215 14.275"
        If you specify the frequency, the band will be correctly set.
    Specify a new transmit power, such as "100W". Enter "0W" to stop recording
        a transmit power.

    Enter a hunter contact:
        Enter the hunter's callsign, followed by optional information in any
        order like sent and received RSTs, hunter transmit power, park to park
        identifier(s) and a comment enclosed in double quotes (or if the
        comment is at the end of the line, it only has to be started with a
        double quote - no need for a closing quote).

        All optional information may be entered in ANY order.
"""
    original_hunter_info = k0rlo.get_input(help, 
        "({}:{}:{}) Hunter contact information: ".format(bands[0],
            display_mode, display_power))

    hunter_info = original_hunter_info.upper()

    #
    #See if new band(s) have been specified
    #
    test = adif.valid_band(hunter_info)
    if type(test) != str:
        #
        #Save both band and no frequencies
        #
        bands = test
        frequencies = []
        continue

    #
    #See ifnew frequency (-ies) have been specified
    #
    test = adif.valid_frequency(hunter_info)
    if type(test) != str:
        #
        #Save both band(s) and frequencies
        #
        (bands, frequencies) = test
        continue

    #
    #See if a new mode has been specified
    #
    test = adif.valid_mode(hunter_info)
    if type(test) != str:
        mode_submode = test
        continue

    #
    #See if a new power has been specified
    #
    test = adif.valid_power(hunter_info)
    if type(test) != str:
        #
        #Save new power. Setting power to "0" will cause no power to be
        #reported.
        #
        #Unpack tuple into activator power [0]
        #
        (power[0],) = test
        continue

    ####
    #### Looks like we have a contact to log, log it
    ####

    #
    #Default to no comment
    #
    comment = ""

    #
    #See if a comment has been specified
    #
    quotes = original_hunter_info.count('"')
    if quotes:
        #
        #There is a comment to be logged. Handle one or two quotes
        #
        if quotes > 2:
            #
            #More than two double quotes, that's an error
            #
            print("""
Error: More than two double quotes '"' detected. A comment must have two double
       quotes surrounding it, or start with a single double quote if at the end
       of the line.
""")
            continue

        #
        #Pull out comment from opening quote to closing quote or EOL (re $)
        #
        comment = re.search(comment_re, original_hunter_info)[0][1:]
        hunter_info = re.sub(comment_re, " ", hunter_info).strip()

        #
        #Remove closing quote if necessary
        #
        if quotes > 1:
            comment = comment[0:-1].strip()

    #
    #Get the current GMT now so all logs for this hunter show
    #the same time.
    #
    utc = time.gmtime()

    #
    #Split input line to see if this is just a hunter (only character
    #string) or RST reports and/or a park-to-park which will specify
    #the park as following character strings.
    #
    hunter_info = re.split(k0rlo.default_split, hunter_info)

    #
    #Get the hunter callsign which is the first (and perhaps
    #only) contents of the list. Parks and RSTs (if any) remain.
    #
    hunter_callsign = hunter_info.pop(0)

    #
    #Start off with checking if it's a bad callsign
    #
    report_error = k0rlo.valid_callsign(hunter_callsign)
    if report_error:
        print(report_error)

    #
    #Initialize bad_info based upon the validation of the callsign
    #
    bad_entry = bool(report_error)

    #
    #Split the remainder of the info into RST reports and parks, if any
    #
    hunter_parks = {}
    hunter_power = {}
    rst = []
    bad_strings = []

    #
    #Look through the free-float format and save optional park, RST and power,
    #if any. Report anything that doesn't match as an error.
    #
    for component in hunter_info:
        #
        #If it's a park, save it as a park
        #
        if re.fullmatch(r'[A-Z]+-\d{4}', component):
            #
            #Eliminate duplicate parks by using dictonary
            #
            hunter_parks[component] = True
            continue
        #
        #If it's an RST, save it as an RST
        #
        if re.fullmatch(r'[1-5][1-9]{1,2}', component):
            #
            #It's an RST number, save it as an RST
            #
            rst.append(component)
            continue
        #
        #If it's a power, save it as a power
        #
        if re.fullmatch(r'\d{1,4}W', component):
            #
            #It's an hunter power, save it as an power removing the "W"
            #
            hunter_power[component] = True
            continue

        #
        #Unrecognized string, save error
        #
        bad_strings.append(component)
        bad_entry = True

    #
    #Verify we have no more than one power entry.
    #
    if hunter_power:
        if len(hunter_power) > 1:
            print("""
Error: More than one power entry. The hunter can only have one power entered.
""")
            bad_entry = True
        #
        #Save receive power - only one entry in the dictonary, get its key
        #and strip the "W" off the end.
        #
        power[1] = list(hunter_power)[0][:-1]


    #
    #Verify we have no more than 2 RST entries
    #
    if len(rst) > 2:
        print("""
Error: More than two RST entries. The RST report you send to the hunter is the
       first RST report, the second RST is what the hunter reports to you.
       Examples: "59", "589" or "59 59".
""")
        #
        #Ask for all the info again
        #
        bad_entry = True

    #
    #Report any strings we didn't recognize
    #
    for errors in bad_strings:
        #
        #Report error
        #
        print("""
Error: "{}" is not a recognized entry. Press <Enter> to get help on how to
       enter information on the hunter contact information line.
""".format(errors))
        bad_entry = True
    #
    #If we got any bad information, skip processing and ask for
    #hunter callsign, RST and park(s) again.
    #
    if bad_entry:
        continue

    ####
    #### Start assembling the record to be logged, start with the stuff
    #### common to all the record(s) to be written. Start with a ADIF record
    #### only containing MY_SIG = POTA
    ####
    log_record = {"MY_SIG":"POTA"}

    #
    #Save the date, time and hunter callsign
    #
    log_record["QSO_DATE"] = time.strftime("%Y%m%d", utc)
    log_record["TIME_ON"] = time.strftime("%H%M%S", utc)
    log_record["CALL"] = hunter_callsign

    #
    #Save transmit, and optionally receive band in record
    #
    for index in range(len(bands)):
        log_record[band_tags[index]] = bands[index]

    #
    #Save mode and submode
    #
    for index in range(len(mode_submode)):
        log_record[mode_tags[index]] = mode_submode[index]

    #
    #Save transmit, and optionally receive frequencies in record
    #
    for index in range(len(frequencies)):
        log_record[frequency_tags[index]] = frequencies[index]

    #
    #Save optional transmit and receive power in record
    #
    for index in range(len(power)):
        if power[index] != "0":
            #
            #If there is a power specified, report it
            #
            log_record[power_tags[index]] = power[index]

    #
    #Save sent and received RST, if specified
    #
    for index in range(len(rst)):
        log_record[rst_tags[index]] = rst[index]

    #
    #Save state if specified
    #
    if state:
        log_record["MY_STATE"] = state

    #
    #Save comment if specified
    #
    if comment:
        log_record["COMMENT"] = comment

    #
    #Log contacts for all operators (any input will skip an
    #operator from having a log entry)
    #
    help = """
Enter "Y" (or just press <Enter>) if the specified operator has performed an
    exchange with the hunter and they wish to receive credit for the contact.
Enter "N" if the specified operator is unable to perform an exchange with
    the hunter or they should not receive credit for the contact.
"""
    for operator in operators:
        #
        #This loop will log entries for ALL the operators that are "sharing a
        #microphone".
        #
        if ((len(operators) > 1) and
            not k0rlo.get_yes_no(help, "Log contact for " + operator, "Y")):
            #
            #If "N" typed, skip this operator
            #
            continue

        #
        #Now write a file for each park we're at
        #
        for park in parks:
            #
            #Log the operator
            #
            log_record["OPERATOR"] = operator

            #
            #Determine STATION_CALLSIGN and logfile name based on if there's a
            #special_event_callsign or not.
            #
            if special_event_callsign:
                log_record["STATION_CALLSIGN"] = special_event_callsign
            else:
                log_record["STATION_CALLSIGN"] = operator

            #
            #Filename is always based on the STATION_CALLSIGN
            #
            log_filename = determine_filename(log_record["STATION_CALLSIGN"], park, state)

            #
            #We wait until we REALLY need to create a log file. Time to see if
            #we need to create the file now, and if so, write the header.
            #
            if not os.path.exists(log_filename):
                #
                #If this log file does not yet exist, create a header
                #
                f = open(log_filename, "w")
                f.write(("Parks On The Air (POTA) rapid log\n" +
                    adif.tag("PROGRAMID", "pota_rapidlog") + "\n" +
                    adif.tag("PROGRAMVERSION", pota_rapidlog_version) +
                    "\n" +
                    adif.tag("CREATED_TIMESTAMP",
                        time.strftime("%Y%m%d %H%M%S", utc)) +
                        "<EOH>\n"))
                f.close()

            #
            #Add this park to the record to be written
            #
            log_record["MY_SIG_INFO"] = park

            if hunter_parks:
                #
                #We have one or more park-to-park contacts to log, open
                #the file and write [perhaps] multiple records
                #
                f = open(log_filename, "a")
                #
                #We're writing Park to park information, so setup the SIG
                log_record["SIG"] = "POTA"

                #
                #Now write records for all park to park parks
                #
                for hunter_park in sorted(hunter_parks.keys()):
                    #
                    #This is a park to park, fill in the addiitional
                    #information
                    #
                    log_record["SIG_INFO"] = hunter_park
                    f.write(adif.record(log_record, adif_tag_support_and_order))
                #
                #Keep the file closed to avoid dataloss
                #
                f.close()
            else:
                #
                #No park to park, write the record for this normal hunter
                #contact
                #
                f = open(log_filename, "a")
                f.write(adif.record(log_record, adif_tag_support_and_order))
                #
                #Keep the file closed to avoid dataloss
                #
                f.close()

exit()
